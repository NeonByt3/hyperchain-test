"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* harmony import */ var jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jotai/vanilla/internals */ \"(ssr)/./node_modules/jotai/esm/vanilla/internals.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction useStore(options) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n}\nfunction Provider({ children, store }) {\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n}\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseStatus = (promise)=>{\n    if (!promise.status) {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n    }\n};\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || // A shim for older React versions\n((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        attachPromiseStatus(promise);\n        throw promise;\n    }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, getValue)=>{\n    let continuablePromise = continuablePromiseMap.get(promise);\n    if (!continuablePromise) {\n        continuablePromise = new Promise((resolve, reject)=>{\n            let curr = promise;\n            const onFulfilled = (me)=>(v)=>{\n                    if (curr === me) {\n                        resolve(v);\n                    }\n                };\n            const onRejected = (me)=>(e)=>{\n                    if (curr === me) {\n                        reject(e);\n                    }\n                };\n            const onAbort = ()=>{\n                try {\n                    const nextValue = getValue();\n                    if (isPromiseLike(nextValue)) {\n                        continuablePromiseMap.set(nextValue, continuablePromise);\n                        curr = nextValue;\n                        nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n                        (0,jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_2__.INTERNAL_registerAbortHandler)(nextValue, onAbort);\n                    } else {\n                        resolve(nextValue);\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            };\n            promise.then(onFulfilled(promise), onRejected(promise));\n            (0,jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_2__.INTERNAL_registerAbortHandler)(promise, onAbort);\n        });\n        continuablePromiseMap.set(promise, continuablePromise);\n    }\n    return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n    const { delay, unstable_promiseStatus: promiseStatus = !react__WEBPACK_IMPORTED_MODULE_0__.use } = options || {};\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (promiseStatus) {\n                try {\n                    const value2 = store.get(atom);\n                    if (isPromiseLike(value2)) {\n                        attachPromiseStatus(createContinuablePromise(value2, ()=>store.get(atom)));\n                    }\n                } catch (e) {}\n            }\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay,\n        promiseStatus\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    if (isPromiseLike(value)) {\n        const promise = createContinuablePromise(value, ()=>store.get(atom));\n        if (promiseStatus) {\n            attachPromiseStatus(promise);\n        }\n        return use(promise);\n    }\n    return value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VUFBVSxVQUFVO2dCQUM3QmEsV0FBV1AsVUFBVU47Z0JBQ3JCO1lBQ0Y7WUFDQU07UUFDRjtRQUNBQTtRQUNBLE9BQU9JO0lBQ1QsR0FBRztRQUFDNUM7UUFBT2lDO1FBQU1DO1FBQU9FO0tBQWM7SUFDdEM1QyxvREFBYUEsQ0FBQ2E7SUFDZCxJQUFJQyxjQUFjRCxRQUFRO1FBQ3hCLE1BQU1LLFVBQVVRLHlCQUF5QmIsT0FBTyxJQUFNTCxNQUFNcUIsR0FBRyxDQUFDWTtRQUNoRSxJQUFJRyxlQUFlO1lBQ2pCM0Isb0JBQW9CQztRQUN0QjtRQUNBLE9BQU9LLElBQUlMO0lBQ2I7SUFDQSxPQUFPTDtBQUNUO0FBRUEsU0FBUzJDLFdBQVdmLElBQUksRUFBRWxDLE9BQU87SUFDL0IsTUFBTUMsUUFBUUYsU0FBU0M7SUFDdkIsTUFBTWtELFVBQVV4RCxrREFBV0EsQ0FDekIsQ0FBQyxHQUFHeUQ7UUFDRixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGdCQUFnQixDQUFFLFlBQVdqQixJQUFHLEdBQUk7WUFDNUYsTUFBTSxJQUFJb0IsTUFBTTtRQUNsQjtRQUNBLE9BQU9yRCxNQUFNK0IsR0FBRyxDQUFDRSxTQUFTaUI7SUFDNUIsR0FDQTtRQUFDbEQ7UUFBT2lDO0tBQUs7SUFFZixPQUFPZ0I7QUFDVDtBQUVBLFNBQVNLLFFBQVFyQixJQUFJLEVBQUVsQyxPQUFPO0lBQzVCLE9BQU87UUFDTGlDLGFBQWFDLE1BQU1sQztRQUNuQix1RUFBdUU7UUFDdkVpRCxXQUFXZixNQUFNbEM7S0FDbEI7QUFDSDtBQUVpRSIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmxkLW1pbmktYXBwLW5leHQxNC8uL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vcmVhY3QubWpzP2FjMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgY3JlYXRlRWxlbWVudCwgdXNlUmVkdWNlciwgdXNlRWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldERlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmUgfSBmcm9tICdqb3RhaS92YW5pbGxhJztcbmltcG9ydCB7IElOVEVSTkFMX3JlZ2lzdGVyQWJvcnRIYW5kbGVyIH0gZnJvbSAnam90YWkvdmFuaWxsYS9pbnRlcm5hbHMnO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KFxuICB2b2lkIDBcbik7XG5mdW5jdGlvbiB1c2VTdG9yZShvcHRpb25zKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICByZXR1cm4gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RvcmUpIHx8IHN0b3JlIHx8IGdldERlZmF1bHRTdG9yZSgpO1xufVxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgc3RvcmVcbn0pIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VSZWYodm9pZCAwKTtcbiAgaWYgKCFzdG9yZSAmJiAhc3RvcmVSZWYuY3VycmVudCkge1xuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBjcmVhdGVTdG9yZSgpO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgIFN0b3JlQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogc3RvcmUgfHwgc3RvcmVSZWYuY3VycmVudFxuICAgIH0sXG4gICAgY2hpbGRyZW5cbiAgKTtcbn1cblxuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGF0dGFjaFByb21pc2VTdGF0dXMgPSAocHJvbWlzZSkgPT4ge1xuICBpZiAoIXByb21pc2Uuc3RhdHVzKSB7XG4gICAgcHJvbWlzZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAodikgPT4ge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSB2O1xuICAgICAgfSxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICBwcm9taXNlLnJlYXNvbiA9IGU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcbmNvbnN0IHVzZSA9IFJlYWN0LnVzZSB8fCAvLyBBIHNoaW0gZm9yIG9sZGVyIFJlYWN0IHZlcnNpb25zXG4oKHByb21pc2UpID0+IHtcbiAgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgIHRocm93IHByb21pc2U7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICByZXR1cm4gcHJvbWlzZS52YWx1ZTtcbiAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgdGhyb3cgcHJvbWlzZS5yZWFzb247XG4gIH0gZWxzZSB7XG4gICAgYXR0YWNoUHJvbWlzZVN0YXR1cyhwcm9taXNlKTtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG59KTtcbmNvbnN0IGNvbnRpbnVhYmxlUHJvbWlzZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgY3JlYXRlQ29udGludWFibGVQcm9taXNlID0gKHByb21pc2UsIGdldFZhbHVlKSA9PiB7XG4gIGxldCBjb250aW51YWJsZVByb21pc2UgPSBjb250aW51YWJsZVByb21pc2VNYXAuZ2V0KHByb21pc2UpO1xuICBpZiAoIWNvbnRpbnVhYmxlUHJvbWlzZSkge1xuICAgIGNvbnRpbnVhYmxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjdXJyID0gcHJvbWlzZTtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gKG1lKSA9PiAodikgPT4ge1xuICAgICAgICBpZiAoY3VyciA9PT0gbWUpIHtcbiAgICAgICAgICByZXNvbHZlKHYpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25SZWplY3RlZCA9IChtZSkgPT4gKGUpID0+IHtcbiAgICAgICAgaWYgKGN1cnIgPT09IG1lKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25BYm9ydCA9ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBnZXRWYWx1ZSgpO1xuICAgICAgICAgIGlmIChpc1Byb21pc2VMaWtlKG5leHRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVhYmxlUHJvbWlzZU1hcC5zZXQobmV4dFZhbHVlLCBjb250aW51YWJsZVByb21pc2UpO1xuICAgICAgICAgICAgY3VyciA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIG5leHRWYWx1ZS50aGVuKG9uRnVsZmlsbGVkKG5leHRWYWx1ZSksIG9uUmVqZWN0ZWQobmV4dFZhbHVlKSk7XG4gICAgICAgICAgICBJTlRFUk5BTF9yZWdpc3RlckFib3J0SGFuZGxlcihuZXh0VmFsdWUsIG9uQWJvcnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKG5leHRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkKHByb21pc2UpLCBvblJlamVjdGVkKHByb21pc2UpKTtcbiAgICAgIElOVEVSTkFMX3JlZ2lzdGVyQWJvcnRIYW5kbGVyKHByb21pc2UsIG9uQWJvcnQpO1xuICAgIH0pO1xuICAgIGNvbnRpbnVhYmxlUHJvbWlzZU1hcC5zZXQocHJvbWlzZSwgY29udGludWFibGVQcm9taXNlKTtcbiAgfVxuICByZXR1cm4gY29udGludWFibGVQcm9taXNlO1xufTtcbmZ1bmN0aW9uIHVzZUF0b21WYWx1ZShhdG9tLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZGVsYXksIHVuc3RhYmxlX3Byb21pc2VTdGF0dXM6IHByb21pc2VTdGF0dXMgPSAhUmVhY3QudXNlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBbW3ZhbHVlRnJvbVJlZHVjZXIsIHN0b3JlRnJvbVJlZHVjZXIsIGF0b21Gcm9tUmVkdWNlcl0sIHJlcmVuZGVyXSA9IHVzZVJlZHVjZXIoXG4gICAgKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHN0b3JlLmdldChhdG9tKTtcbiAgICAgIGlmIChPYmplY3QuaXMocHJldlswXSwgbmV4dFZhbHVlKSAmJiBwcmV2WzFdID09PSBzdG9yZSAmJiBwcmV2WzJdID09PSBhdG9tKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXh0VmFsdWUsIHN0b3JlLCBhdG9tXTtcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICAoKSA9PiBbc3RvcmUuZ2V0KGF0b20pLCBzdG9yZSwgYXRvbV1cbiAgKTtcbiAgbGV0IHZhbHVlID0gdmFsdWVGcm9tUmVkdWNlcjtcbiAgaWYgKHN0b3JlRnJvbVJlZHVjZXIgIT09IHN0b3JlIHx8IGF0b21Gcm9tUmVkdWNlciAhPT0gYXRvbSkge1xuICAgIHJlcmVuZGVyKCk7XG4gICAgdmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gIH1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YihhdG9tLCAoKSA9PiB7XG4gICAgICBpZiAocHJvbWlzZVN0YXR1cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IHN0b3JlLmdldChhdG9tKTtcbiAgICAgICAgICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZTIpKSB7XG4gICAgICAgICAgICBhdHRhY2hQcm9taXNlU3RhdHVzKFxuICAgICAgICAgICAgICBjcmVhdGVDb250aW51YWJsZVByb21pc2UodmFsdWUyLCAoKSA9PiBzdG9yZS5nZXQoYXRvbSkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVyZW5kZXIsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVyZW5kZXIoKTtcbiAgICB9KTtcbiAgICByZXJlbmRlcigpO1xuICAgIHJldHVybiB1bnN1YjtcbiAgfSwgW3N0b3JlLCBhdG9tLCBkZWxheSwgcHJvbWlzZVN0YXR1c10pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWUpKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZUNvbnRpbnVhYmxlUHJvbWlzZSh2YWx1ZSwgKCkgPT4gc3RvcmUuZ2V0KGF0b20pKTtcbiAgICBpZiAocHJvbWlzZVN0YXR1cykge1xuICAgICAgYXR0YWNoUHJvbWlzZVN0YXR1cyhwcm9taXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZShwcm9taXNlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVNldEF0b20oYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBzZXRBdG9tID0gdXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhKFwid3JpdGVcIiBpbiBhdG9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Qgd3JpdGFibGUgYXRvbVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdG9yZS5zZXQoYXRvbSwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBbc3RvcmUsIGF0b21dXG4gICk7XG4gIHJldHVybiBzZXRBdG9tO1xufVxuXG5mdW5jdGlvbiB1c2VBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucyksXG4gICAgLy8gV2UgZG8gd3JvbmcgdHlwZSBhc3NlcnRpb24gaGVyZSwgd2hpY2ggcmVzdWx0cyBpbiB0aHJvd2luZyBhbiBlcnJvci5cbiAgICB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpXG4gIF07XG59XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCB1c2VBdG9tLCB1c2VBdG9tVmFsdWUsIHVzZVNldEF0b20sIHVzZVN0b3JlIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVJlZiIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VSZWR1Y2VyIiwidXNlRWZmZWN0IiwidXNlRGVidWdWYWx1ZSIsInVzZUNhbGxiYWNrIiwiZ2V0RGVmYXVsdFN0b3JlIiwiY3JlYXRlU3RvcmUiLCJJTlRFUk5BTF9yZWdpc3RlckFib3J0SGFuZGxlciIsIlN0b3JlQ29udGV4dCIsInVzZVN0b3JlIiwib3B0aW9ucyIsInN0b3JlIiwiUHJvdmlkZXIiLCJjaGlsZHJlbiIsInN0b3JlUmVmIiwiY3VycmVudCIsInZhbHVlIiwiaXNQcm9taXNlTGlrZSIsIngiLCJ0aGVuIiwiYXR0YWNoUHJvbWlzZVN0YXR1cyIsInByb21pc2UiLCJzdGF0dXMiLCJ2IiwiZSIsInJlYXNvbiIsInVzZSIsImNvbnRpbnVhYmxlUHJvbWlzZU1hcCIsIldlYWtNYXAiLCJjcmVhdGVDb250aW51YWJsZVByb21pc2UiLCJnZXRWYWx1ZSIsImNvbnRpbnVhYmxlUHJvbWlzZSIsImdldCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY3VyciIsIm9uRnVsZmlsbGVkIiwibWUiLCJvblJlamVjdGVkIiwib25BYm9ydCIsIm5leHRWYWx1ZSIsInNldCIsInVzZUF0b21WYWx1ZSIsImF0b20iLCJkZWxheSIsInVuc3RhYmxlX3Byb21pc2VTdGF0dXMiLCJwcm9taXNlU3RhdHVzIiwidmFsdWVGcm9tUmVkdWNlciIsInN0b3JlRnJvbVJlZHVjZXIiLCJhdG9tRnJvbVJlZHVjZXIiLCJyZXJlbmRlciIsInByZXYiLCJPYmplY3QiLCJpcyIsInVuc3ViIiwic3ViIiwidmFsdWUyIiwic2V0VGltZW91dCIsInVzZVNldEF0b20iLCJzZXRBdG9tIiwiYXJncyIsImVudiIsIk1PREUiLCJFcnJvciIsInVzZUF0b20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INTERNAL_overrideCreateStore: () => (/* binding */ INTERNAL_overrideCreateStore),\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\n/* harmony import */ var jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jotai/vanilla/internals */ \"(ssr)/./node_modules/jotai/esm/vanilla/internals.mjs\");\n\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return ( false ? 0 : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst createDevStoreRev4 = () => {\n  let inRestoreAtom = 0;\n  const storeHooks = (0,jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_initializeStoreHooks)({});\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedAtoms = /* @__PURE__ */ new WeakMap();\n  const store = (0,jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_buildStoreRev1)(\n    atomStateMap,\n    mountedAtoms,\n    void 0,\n    void 0,\n    void 0,\n    void 0,\n    storeHooks,\n    void 0,\n    (atom, get, set, ...args) => {\n      if (inRestoreAtom) {\n        return set(atom, ...args);\n      }\n      return atom.write(get, set, ...args);\n    }\n  );\n  const debugMountedAtoms = /* @__PURE__ */ new Set();\n  storeHooks.m.add(void 0, (atom) => {\n    debugMountedAtoms.add(atom);\n    const atomState = atomStateMap.get(atom);\n    atomState.m = mountedAtoms.get(atom);\n  });\n  storeHooks.u.add(void 0, (atom) => {\n    debugMountedAtoms.delete(atom);\n    const atomState = atomStateMap.get(atom);\n    delete atomState.m;\n  });\n  const devStore = {\n    // store dev methods (these are tentative and subject to change without notice)\n    dev4_get_internal_weak_map: () => {\n      console.log(\"Deprecated: Use devstore from the devtools library\");\n      return atomStateMap;\n    },\n    dev4_get_mounted_atoms: () => debugMountedAtoms,\n    dev4_restore_atoms: (values) => {\n      const restoreAtom = {\n        read: () => null,\n        write: (_get, set) => {\n          ++inRestoreAtom;\n          try {\n            for (const [atom, value] of values) {\n              if (\"init\" in atom) {\n                set(atom, value);\n              }\n            }\n          } finally {\n            --inRestoreAtom;\n          }\n        }\n      };\n      store.set(restoreAtom);\n    }\n  };\n  return Object.assign(store, devStore);\n};\nlet overiddenCreateStore;\nfunction INTERNAL_overrideCreateStore(fn) {\n  overiddenCreateStore = fn(overiddenCreateStore);\n}\nfunction createStore() {\n  if (overiddenCreateStore) {\n    return overiddenCreateStore();\n  }\n  if (( false ? 0 : void 0) !== \"production\") {\n    return createDevStoreRev4();\n  }\n  return (0,jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_buildStoreRev1)();\n}\nlet defaultStore;\nfunction getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if (( false ? 0 : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlHOztBQUVqRztBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBLGNBQWMsTUFBZSxHQUFHLENBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHNGQUE2QixHQUFHO0FBQ3JEO0FBQ0E7QUFDQSxnQkFBZ0IsZ0ZBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQSxTQUFTLGdGQUF1QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFlLEdBQUcsQ0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ybGQtbWluaS1hcHAtbmV4dDE0Ly4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS92YW5pbGxhLm1qcz8zZWVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElOVEVSTkFMX2J1aWxkU3RvcmVSZXYxLCBJTlRFUk5BTF9pbml0aWFsaXplU3RvcmVIb29rcyB9IGZyb20gJ2pvdGFpL3ZhbmlsbGEvaW50ZXJuYWxzJztcblxubGV0IGtleUNvdW50ID0gMDtcbmZ1bmN0aW9uIGF0b20ocmVhZCwgd3JpdGUpIHtcbiAgY29uc3Qga2V5ID0gYGF0b20keysra2V5Q291bnR9YDtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMuZGVidWdMYWJlbCA/IGtleSArIFwiOlwiICsgdGhpcy5kZWJ1Z0xhYmVsIDoga2V5O1xuICAgIH1cbiAgfTtcbiAgaWYgKHR5cGVvZiByZWFkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25maWcucmVhZCA9IHJlYWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLmluaXQgPSByZWFkO1xuICAgIGNvbmZpZy5yZWFkID0gZGVmYXVsdFJlYWQ7XG4gICAgY29uZmlnLndyaXRlID0gZGVmYXVsdFdyaXRlO1xuICB9XG4gIGlmICh3cml0ZSkge1xuICAgIGNvbmZpZy53cml0ZSA9IHdyaXRlO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVhZChnZXQpIHtcbiAgcmV0dXJuIGdldCh0aGlzKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZShnZXQsIHNldCwgYXJnKSB7XG4gIHJldHVybiBzZXQoXG4gICAgdGhpcyxcbiAgICB0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIgPyBhcmcoZ2V0KHRoaXMpKSA6IGFyZ1xuICApO1xufVxuXG5jb25zdCBjcmVhdGVEZXZTdG9yZVJldjQgPSAoKSA9PiB7XG4gIGxldCBpblJlc3RvcmVBdG9tID0gMDtcbiAgY29uc3Qgc3RvcmVIb29rcyA9IElOVEVSTkFMX2luaXRpYWxpemVTdG9yZUhvb2tzKHt9KTtcbiAgY29uc3QgYXRvbVN0YXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IG1vdW50ZWRBdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBzdG9yZSA9IElOVEVSTkFMX2J1aWxkU3RvcmVSZXYxKFxuICAgIGF0b21TdGF0ZU1hcCxcbiAgICBtb3VudGVkQXRvbXMsXG4gICAgdm9pZCAwLFxuICAgIHZvaWQgMCxcbiAgICB2b2lkIDAsXG4gICAgdm9pZCAwLFxuICAgIHN0b3JlSG9va3MsXG4gICAgdm9pZCAwLFxuICAgIChhdG9tLCBnZXQsIHNldCwgLi4uYXJncykgPT4ge1xuICAgICAgaWYgKGluUmVzdG9yZUF0b20pIHtcbiAgICAgICAgcmV0dXJuIHNldChhdG9tLCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdG9tLndyaXRlKGdldCwgc2V0LCAuLi5hcmdzKTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IGRlYnVnTW91bnRlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgc3RvcmVIb29rcy5tLmFkZCh2b2lkIDAsIChhdG9tKSA9PiB7XG4gICAgZGVidWdNb3VudGVkQXRvbXMuYWRkKGF0b20pO1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gICAgYXRvbVN0YXRlLm0gPSBtb3VudGVkQXRvbXMuZ2V0KGF0b20pO1xuICB9KTtcbiAgc3RvcmVIb29rcy51LmFkZCh2b2lkIDAsIChhdG9tKSA9PiB7XG4gICAgZGVidWdNb3VudGVkQXRvbXMuZGVsZXRlKGF0b20pO1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gICAgZGVsZXRlIGF0b21TdGF0ZS5tO1xuICB9KTtcbiAgY29uc3QgZGV2U3RvcmUgPSB7XG4gICAgLy8gc3RvcmUgZGV2IG1ldGhvZHMgKHRoZXNlIGFyZSB0ZW50YXRpdmUgYW5kIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlKVxuICAgIGRldjRfZ2V0X2ludGVybmFsX3dlYWtfbWFwOiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIkRlcHJlY2F0ZWQ6IFVzZSBkZXZzdG9yZSBmcm9tIHRoZSBkZXZ0b29scyBsaWJyYXJ5XCIpO1xuICAgICAgcmV0dXJuIGF0b21TdGF0ZU1hcDtcbiAgICB9LFxuICAgIGRldjRfZ2V0X21vdW50ZWRfYXRvbXM6ICgpID0+IGRlYnVnTW91bnRlZEF0b21zLFxuICAgIGRldjRfcmVzdG9yZV9hdG9tczogKHZhbHVlcykgPT4ge1xuICAgICAgY29uc3QgcmVzdG9yZUF0b20gPSB7XG4gICAgICAgIHJlYWQ6ICgpID0+IG51bGwsXG4gICAgICAgIHdyaXRlOiAoX2dldCwgc2V0KSA9PiB7XG4gICAgICAgICAgKytpblJlc3RvcmVBdG9tO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFthdG9tLCB2YWx1ZV0gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChcImluaXRcIiBpbiBhdG9tKSB7XG4gICAgICAgICAgICAgICAgc2V0KGF0b20sIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAtLWluUmVzdG9yZUF0b207XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc3RvcmUuc2V0KHJlc3RvcmVBdG9tKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHN0b3JlLCBkZXZTdG9yZSk7XG59O1xubGV0IG92ZXJpZGRlbkNyZWF0ZVN0b3JlO1xuZnVuY3Rpb24gSU5URVJOQUxfb3ZlcnJpZGVDcmVhdGVTdG9yZShmbikge1xuICBvdmVyaWRkZW5DcmVhdGVTdG9yZSA9IGZuKG92ZXJpZGRlbkNyZWF0ZVN0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKCkge1xuICBpZiAob3ZlcmlkZGVuQ3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gb3ZlcmlkZGVuQ3JlYXRlU3RvcmUoKTtcbiAgfVxuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGV2U3RvcmVSZXY0KCk7XG4gIH1cbiAgcmV0dXJuIElOVEVSTkFMX2J1aWxkU3RvcmVSZXYxKCk7XG59XG5sZXQgZGVmYXVsdFN0b3JlO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0b3JlKCkge1xuICBpZiAoIWRlZmF1bHRTdG9yZSkge1xuICAgIGRlZmF1bHRTdG9yZSA9IGNyZWF0ZVN0b3JlKCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fIHx8IChnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fID0gZGVmYXVsdFN0b3JlKTtcbiAgICAgIGlmIChnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fICE9PSBkZWZhdWx0U3RvcmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgSm90YWkgaW5zdGFuY2VzLiBJdCBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciB3aXRoIHRoZSBkZWZhdWx0IHN0b3JlLiBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL2pvdGFpL2Rpc2N1c3Npb25zLzIwNDRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0b3JlO1xufVxuXG5leHBvcnQgeyBJTlRFUk5BTF9vdmVycmlkZUNyZWF0ZVN0b3JlLCBhdG9tLCBjcmVhdGVTdG9yZSwgZ2V0RGVmYXVsdFN0b3JlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla/internals.mjs":
/*!******************************************************!*\
  !*** ./node_modules/jotai/esm/vanilla/internals.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INTERNAL_abortPromise: () => (/* binding */ INTERNAL_abortPromise),\n/* harmony export */   INTERNAL_addPendingPromiseToDependency: () => (/* binding */ INTERNAL_addPendingPromiseToDependency),\n/* harmony export */   INTERNAL_buildStoreRev1: () => (/* binding */ INTERNAL_buildStoreRev1),\n/* harmony export */   INTERNAL_getBuildingBlocksRev1: () => (/* binding */ INTERNAL_getBuildingBlocksRev1),\n/* harmony export */   INTERNAL_getMountedOrPendingDependents: () => (/* binding */ INTERNAL_getMountedOrPendingDependents),\n/* harmony export */   INTERNAL_hasInitialValue: () => (/* binding */ INTERNAL_hasInitialValue),\n/* harmony export */   INTERNAL_initializeStoreHooks: () => (/* binding */ INTERNAL_initializeStoreHooks),\n/* harmony export */   INTERNAL_isActuallyWritableAtom: () => (/* binding */ INTERNAL_isActuallyWritableAtom),\n/* harmony export */   INTERNAL_isAtomStateInitialized: () => (/* binding */ INTERNAL_isAtomStateInitialized),\n/* harmony export */   INTERNAL_isPendingPromise: () => (/* binding */ INTERNAL_isPendingPromise),\n/* harmony export */   INTERNAL_isPromiseLike: () => (/* binding */ INTERNAL_isPromiseLike),\n/* harmony export */   INTERNAL_isSelfAtom: () => (/* binding */ INTERNAL_isSelfAtom),\n/* harmony export */   INTERNAL_promiseStateMap: () => (/* binding */ INTERNAL_promiseStateMap),\n/* harmony export */   INTERNAL_registerAbortHandler: () => (/* binding */ INTERNAL_registerAbortHandler),\n/* harmony export */   INTERNAL_returnAtomValue: () => (/* binding */ INTERNAL_returnAtomValue),\n/* harmony export */   INTERNAL_setAtomStateValueOrPromise: () => (/* binding */ INTERNAL_setAtomStateValueOrPromise)\n/* harmony export */ });\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if (( false ? 0 : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst promiseStateMap = /* @__PURE__ */ new WeakMap();\nconst isPendingPromise = (value) => {\n  var _a;\n  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);\n};\nconst abortPromise = (promise) => {\n  const promiseState = promiseStateMap.get(promise);\n  if (promiseState == null ? void 0 : promiseState[0]) {\n    promiseState[0] = false;\n    promiseState[1].forEach((fn) => fn());\n  }\n};\nconst registerAbortHandler = (promise, abortHandler) => {\n  let promiseState = promiseStateMap.get(promise);\n  if (!promiseState) {\n    promiseState = [true, /* @__PURE__ */ new Set()];\n    promiseStateMap.set(promise, promiseState);\n    const settle = () => {\n      promiseState[0] = false;\n    };\n    promise.then(settle, settle);\n  }\n  promiseState[1].add(abortHandler);\n};\nconst isPromiseLike = (p) => typeof (p == null ? void 0 : p.then) === \"function\";\nconst addPendingPromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst setAtomStateValueOrPromise = (atom, valueOrPromise, ensureAtomState) => {\n  const atomState = ensureAtomState(atom);\n  const hasPrevValue = \"v\" in atomState;\n  const prevValue = atomState.v;\n  if (isPromiseLike(valueOrPromise)) {\n    for (const a of atomState.d.keys()) {\n      addPendingPromiseToDependency(atom, valueOrPromise, ensureAtomState(a));\n    }\n  }\n  atomState.v = valueOrPromise;\n  delete atomState.e;\n  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n    ++atomState.n;\n    if (isPromiseLike(prevValue)) {\n      abortPromise(prevValue);\n    }\n  }\n};\nconst getMountedOrPendingDependents = (atom, atomState, mountedMap) => {\n  var _a;\n  const dependents = /* @__PURE__ */ new Set();\n  for (const a of ((_a = mountedMap.get(atom)) == null ? void 0 : _a.t) || []) {\n    if (mountedMap.has(a)) {\n      dependents.add(a);\n    }\n  }\n  for (const atomWithPendingPromise of atomState.p) {\n    dependents.add(atomWithPendingPromise);\n  }\n  return dependents;\n};\nconst createStoreHook = () => {\n  const callbacks = /* @__PURE__ */ new Set();\n  const notify = () => {\n    callbacks.forEach((fn) => fn());\n  };\n  notify.add = (fn) => {\n    callbacks.add(fn);\n    return () => {\n      callbacks.delete(fn);\n    };\n  };\n  return notify;\n};\nconst createStoreHookForAtoms = () => {\n  const all = {};\n  const callbacks = /* @__PURE__ */ new WeakMap();\n  const notify = (atom) => {\n    var _a, _b;\n    (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn) => fn(atom));\n    (_b = callbacks.get(atom)) == null ? void 0 : _b.forEach((fn) => fn());\n  };\n  notify.add = (atom, fn) => {\n    const key = atom || all;\n    const fns = (callbacks.has(key) ? callbacks : callbacks.set(key, /* @__PURE__ */ new Set())).get(key);\n    fns.add(fn);\n    return () => {\n      fns == null ? void 0 : fns.delete(fn);\n      if (!fns.size) {\n        callbacks.delete(key);\n      }\n    };\n  };\n  return notify;\n};\nconst initializeStoreHooks = (storeHooks) => {\n  storeHooks.c || (storeHooks.c = createStoreHookForAtoms());\n  storeHooks.m || (storeHooks.m = createStoreHookForAtoms());\n  storeHooks.u || (storeHooks.u = createStoreHookForAtoms());\n  storeHooks.f || (storeHooks.f = createStoreHook());\n  return storeHooks;\n};\nconst BUILDING_BLOCKS = Symbol();\nconst getBuildingBlocks = (store) => store[BUILDING_BLOCKS];\nconst buildStore = (atomStateMap = /* @__PURE__ */ new WeakMap(), mountedMap = /* @__PURE__ */ new WeakMap(), invalidatedAtoms = /* @__PURE__ */ new WeakMap(), changedAtoms = /* @__PURE__ */ new Set(), mountCallbacks = /* @__PURE__ */ new Set(), unmountCallbacks = /* @__PURE__ */ new Set(), storeHooks = {}, atomRead = (atom, ...params) => atom.read(...params), atomWrite = (atom, ...params) => atom.write(...params), atomOnInit = (atom, store) => {\n  var _a;\n  return (_a = atom.unstable_onInit) == null ? void 0 : _a.call(atom, store);\n}, atomOnMount = (atom, setAtom) => {\n  var _a;\n  return (_a = atom.onMount) == null ? void 0 : _a.call(atom, setAtom);\n}, ...buildingBlockFunctions) => {\n  const ensureAtomState = buildingBlockFunctions[0] || ((atom) => {\n    if (( false ? 0 : void 0) !== \"production\" && !atom) {\n      throw new Error(\"Atom is undefined or null\");\n    }\n    let atomState = atomStateMap.get(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      atomStateMap.set(atom, atomState);\n      atomOnInit == null ? void 0 : atomOnInit(atom, store);\n    }\n    return atomState;\n  });\n  const flushCallbacks = buildingBlockFunctions[1] || (() => {\n    const errors = [];\n    const call = (fn) => {\n      try {\n        fn();\n      } catch (e) {\n        errors.push(e);\n      }\n    };\n    do {\n      if (storeHooks.f) {\n        call(storeHooks.f);\n      }\n      const callbacks = /* @__PURE__ */ new Set();\n      const add = callbacks.add.bind(callbacks);\n      changedAtoms.forEach((atom) => {\n        var _a;\n        return (_a = mountedMap.get(atom)) == null ? void 0 : _a.l.forEach(add);\n      });\n      changedAtoms.clear();\n      unmountCallbacks.forEach(add);\n      unmountCallbacks.clear();\n      mountCallbacks.forEach(add);\n      mountCallbacks.clear();\n      callbacks.forEach(call);\n      if (changedAtoms.size) {\n        recomputeInvalidatedAtoms();\n      }\n    } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n    if (errors.length) {\n      throw new AggregateError(errors);\n    }\n  });\n  const recomputeInvalidatedAtoms = buildingBlockFunctions[2] || (() => {\n    const topSortedReversed = [];\n    const visiting = /* @__PURE__ */ new WeakSet();\n    const visited = /* @__PURE__ */ new WeakSet();\n    const stack = Array.from(changedAtoms);\n    while (stack.length) {\n      const a = stack[stack.length - 1];\n      const aState = ensureAtomState(a);\n      if (visited.has(a)) {\n        stack.pop();\n        continue;\n      }\n      if (visiting.has(a)) {\n        if (invalidatedAtoms.get(a) === aState.n) {\n          topSortedReversed.push([a, aState]);\n        } else if (( false ? 0 : void 0) !== \"production\" && invalidatedAtoms.has(a)) {\n          throw new Error(\"[Bug] invalidated atom exists\");\n        }\n        visited.add(a);\n        stack.pop();\n        continue;\n      }\n      visiting.add(a);\n      for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n        if (!visiting.has(d)) {\n          stack.push(d);\n        }\n      }\n    }\n    for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n      const [a, aState] = topSortedReversed[i];\n      let hasChangedDeps = false;\n      for (const dep of aState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        readAtomState(a);\n        mountDependencies(a);\n      }\n      invalidatedAtoms.delete(a);\n    }\n  });\n  const readAtomState = buildingBlockFunctions[3] || ((atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    if (isAtomStateInitialized(atomState)) {\n      if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(a).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const mountDependenciesIfAsync = () => {\n      if (mountedMap.has(atom)) {\n        mountDependencies(atom);\n        recomputeInvalidatedAtoms();\n        flushCallbacks();\n      }\n    };\n    const getter = (a) => {\n      var _a2;\n      if (isSelfAtom(atom, a)) {\n        const aState2 = ensureAtomState(a);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, a.init, ensureAtomState);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(a);\n      try {\n        return returnAtomValue(aState);\n      } finally {\n        atomState.d.set(a, aState.n);\n        if (isPendingPromise(atomState.v)) {\n          addPendingPromiseToDependency(atom, atomState.v, aState);\n        }\n        (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom);\n        if (!isSync) {\n          mountDependenciesIfAsync();\n        }\n      }\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if (( false ? 0 : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              try {\n                return writeAtomState(atom, ...args);\n              } finally {\n                recomputeInvalidatedAtoms();\n                flushCallbacks();\n              }\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    const prevEpochNumber = atomState.n;\n    try {\n      const valueOrPromise = atomRead(atom, getter, options);\n      setAtomStateValueOrPromise(atom, valueOrPromise, ensureAtomState);\n      if (isPromiseLike(valueOrPromise)) {\n        registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n        valueOrPromise.then(\n          mountDependenciesIfAsync,\n          mountDependenciesIfAsync\n        );\n      }\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n      if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom) === prevEpochNumber) {\n        invalidatedAtoms.set(atom, atomState.n);\n        changedAtoms.add(atom);\n        (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, atom);\n      }\n    }\n  });\n  const invalidateDependents = buildingBlockFunctions[4] || ((atom) => {\n    const stack = [atom];\n    while (stack.length) {\n      const a = stack.pop();\n      const aState = ensureAtomState(a);\n      for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n        const dState = ensureAtomState(d);\n        invalidatedAtoms.set(d, dState.n);\n        stack.push(d);\n      }\n    }\n  });\n  const writeAtomState = buildingBlockFunctions[5] || ((atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      var _a;\n      const aState = ensureAtomState(a);\n      try {\n        if (isSelfAtom(atom, a)) {\n          if (!hasInitialValue(a)) {\n            throw new Error(\"atom not writable\");\n          }\n          const prevEpochNumber = aState.n;\n          const v = args2[0];\n          setAtomStateValueOrPromise(a, v, ensureAtomState);\n          mountDependencies(a);\n          if (prevEpochNumber !== aState.n) {\n            changedAtoms.add(a);\n            (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n            invalidateDependents(a);\n          }\n          return void 0;\n        } else {\n          return writeAtomState(a, ...args2);\n        }\n      } finally {\n        if (!isSync) {\n          recomputeInvalidatedAtoms();\n          flushCallbacks();\n        }\n      }\n    };\n    try {\n      return atomWrite(atom, getter, setter, ...args);\n    } finally {\n      isSync = false;\n    }\n  });\n  const mountDependencies = buildingBlockFunctions[6] || ((atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    const mounted = mountedMap.get(atom);\n    if (mounted && !isPendingPromise(atomState.v)) {\n      for (const [a, n] of atomState.d) {\n        if (!mounted.d.has(a)) {\n          const aState = ensureAtomState(a);\n          const aMounted = mountAtom(a);\n          aMounted.t.add(atom);\n          mounted.d.add(a);\n          if (n !== aState.n) {\n            changedAtoms.add(a);\n            (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n            invalidateDependents(a);\n          }\n        }\n      }\n      for (const a of mounted.d || []) {\n        if (!atomState.d.has(a)) {\n          mounted.d.delete(a);\n          const aMounted = unmountAtom(a);\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\n        }\n      }\n    }\n  });\n  const mountAtom = buildingBlockFunctions[7] || ((atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      readAtomState(atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(a);\n        aMounted.t.add(atom);\n      }\n      mounted = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      mountedMap.set(atom, mounted);\n      (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom);\n      if (isActuallyWritableAtom(atom)) {\n        const processOnMount = () => {\n          let isSync = true;\n          const setAtom = (...args) => {\n            try {\n              return writeAtomState(atom, ...args);\n            } finally {\n              if (!isSync) {\n                recomputeInvalidatedAtoms();\n                flushCallbacks();\n              }\n            }\n          };\n          try {\n            const onUnmount = atomOnMount(atom, setAtom);\n            if (onUnmount) {\n              mounted.u = () => {\n                isSync = true;\n                try {\n                  onUnmount();\n                } finally {\n                  isSync = false;\n                }\n              };\n            }\n          } finally {\n            isSync = false;\n          }\n        };\n        mountCallbacks.add(processOnMount);\n      }\n    }\n    return mounted;\n  });\n  const unmountAtom = buildingBlockFunctions[8] || ((atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    let mounted = mountedMap.get(atom);\n    if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {\n      var _a2;\n      return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom);\n    })) {\n      if (mounted.u) {\n        unmountCallbacks.add(mounted.u);\n      }\n      mounted = void 0;\n      mountedMap.delete(atom);\n      (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n      return void 0;\n    }\n    return mounted;\n  });\n  const buildingBlocks = [\n    // store state\n    atomStateMap,\n    mountedMap,\n    invalidatedAtoms,\n    changedAtoms,\n    mountCallbacks,\n    unmountCallbacks,\n    storeHooks,\n    // atom interceptors\n    atomRead,\n    atomWrite,\n    atomOnInit,\n    atomOnMount,\n    // building-block functions\n    ensureAtomState,\n    flushCallbacks,\n    recomputeInvalidatedAtoms,\n    readAtomState,\n    invalidateDependents,\n    writeAtomState,\n    mountDependencies,\n    mountAtom,\n    unmountAtom\n  ];\n  const store = {\n    get: (atom) => returnAtomValue(readAtomState(atom)),\n    set: (atom, ...args) => {\n      try {\n        return writeAtomState(atom, ...args);\n      } finally {\n        recomputeInvalidatedAtoms();\n        flushCallbacks();\n      }\n    },\n    sub: (atom, listener) => {\n      const mounted = mountAtom(atom);\n      const listeners = mounted.l;\n      listeners.add(listener);\n      flushCallbacks();\n      return () => {\n        listeners.delete(listener);\n        unmountAtom(atom);\n        flushCallbacks();\n      };\n    }\n  };\n  Object.defineProperty(store, BUILDING_BLOCKS, { value: buildingBlocks });\n  return store;\n};\nconst INTERNAL_buildStoreRev1 = buildStore;\nconst INTERNAL_getBuildingBlocksRev1 = getBuildingBlocks;\nconst INTERNAL_initializeStoreHooks = initializeStoreHooks;\nconst INTERNAL_isSelfAtom = isSelfAtom;\nconst INTERNAL_hasInitialValue = hasInitialValue;\nconst INTERNAL_isActuallyWritableAtom = isActuallyWritableAtom;\nconst INTERNAL_isAtomStateInitialized = isAtomStateInitialized;\nconst INTERNAL_returnAtomValue = returnAtomValue;\nconst INTERNAL_promiseStateMap = promiseStateMap;\nconst INTERNAL_isPendingPromise = isPendingPromise;\nconst INTERNAL_abortPromise = abortPromise;\nconst INTERNAL_registerAbortHandler = registerAbortHandler;\nconst INTERNAL_isPromiseLike = isPromiseLike;\nconst INTERNAL_addPendingPromiseToDependency = addPendingPromiseToDependency;\nconst INTERNAL_setAtomStateValueOrPromise = setAtomStateValueOrPromise;\nconst INTERNAL_getMountedOrPendingDependents = getMountedOrPendingDependents;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEvaW50ZXJuYWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1UQUFtVDtBQUNuVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxTQUFTLE1BQWUsR0FBRyxDQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVSxNQUFlLEdBQUcsQ0FBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWEsTUFBZSxHQUFHLENBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQWUsR0FBRyxDQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3JsZC1taW5pLWFwcC1uZXh0MTQvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEvaW50ZXJuYWxzLm1qcz9iOWE1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzU2VsZkF0b20gPSAoYXRvbSwgYSkgPT4gYXRvbS51bnN0YWJsZV9pcyA/IGF0b20udW5zdGFibGVfaXMoYSkgOiBhID09PSBhdG9tO1xuY29uc3QgaGFzSW5pdGlhbFZhbHVlID0gKGF0b20pID0+IFwiaW5pdFwiIGluIGF0b207XG5jb25zdCBpc0FjdHVhbGx5V3JpdGFibGVBdG9tID0gKGF0b20pID0+ICEhYXRvbS53cml0ZTtcbmNvbnN0IGlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQgPSAoYXRvbVN0YXRlKSA9PiBcInZcIiBpbiBhdG9tU3RhdGUgfHwgXCJlXCIgaW4gYXRvbVN0YXRlO1xuY29uc3QgcmV0dXJuQXRvbVZhbHVlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gIH1cbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ2XCIgaW4gYXRvbVN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltCdWddIGF0b20gc3RhdGUgaXMgbm90IGluaXRpYWxpemVkXCIpO1xuICB9XG4gIHJldHVybiBhdG9tU3RhdGUudjtcbn07XG5jb25zdCBwcm9taXNlU3RhdGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGlzUGVuZGluZ1Byb21pc2UgPSAodmFsdWUpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gaXNQcm9taXNlTGlrZSh2YWx1ZSkgJiYgISEoKF9hID0gcHJvbWlzZVN0YXRlTWFwLmdldCh2YWx1ZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXSk7XG59O1xuY29uc3QgYWJvcnRQcm9taXNlID0gKHByb21pc2UpID0+IHtcbiAgY29uc3QgcHJvbWlzZVN0YXRlID0gcHJvbWlzZVN0YXRlTWFwLmdldChwcm9taXNlKTtcbiAgaWYgKHByb21pc2VTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJvbWlzZVN0YXRlWzBdKSB7XG4gICAgcHJvbWlzZVN0YXRlWzBdID0gZmFsc2U7XG4gICAgcHJvbWlzZVN0YXRlWzFdLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgfVxufTtcbmNvbnN0IHJlZ2lzdGVyQWJvcnRIYW5kbGVyID0gKHByb21pc2UsIGFib3J0SGFuZGxlcikgPT4ge1xuICBsZXQgcHJvbWlzZVN0YXRlID0gcHJvbWlzZVN0YXRlTWFwLmdldChwcm9taXNlKTtcbiAgaWYgKCFwcm9taXNlU3RhdGUpIHtcbiAgICBwcm9taXNlU3RhdGUgPSBbdHJ1ZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKV07XG4gICAgcHJvbWlzZVN0YXRlTWFwLnNldChwcm9taXNlLCBwcm9taXNlU3RhdGUpO1xuICAgIGNvbnN0IHNldHRsZSA9ICgpID0+IHtcbiAgICAgIHByb21pc2VTdGF0ZVswXSA9IGZhbHNlO1xuICAgIH07XG4gICAgcHJvbWlzZS50aGVuKHNldHRsZSwgc2V0dGxlKTtcbiAgfVxuICBwcm9taXNlU3RhdGVbMV0uYWRkKGFib3J0SGFuZGxlcik7XG59O1xuY29uc3QgaXNQcm9taXNlTGlrZSA9IChwKSA9PiB0eXBlb2YgKHAgPT0gbnVsbCA/IHZvaWQgMCA6IHAudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGFkZFBlbmRpbmdQcm9taXNlVG9EZXBlbmRlbmN5ID0gKGF0b20sIHByb21pc2UsIGRlcGVuZGVuY3lBdG9tU3RhdGUpID0+IHtcbiAgaWYgKCFkZXBlbmRlbmN5QXRvbVN0YXRlLnAuaGFzKGF0b20pKSB7XG4gICAgZGVwZW5kZW5jeUF0b21TdGF0ZS5wLmFkZChhdG9tKTtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGRlcGVuZGVuY3lBdG9tU3RhdGUucC5kZWxldGUoYXRvbSk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBkZXBlbmRlbmN5QXRvbVN0YXRlLnAuZGVsZXRlKGF0b20pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5jb25zdCBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZSA9IChhdG9tLCB2YWx1ZU9yUHJvbWlzZSwgZW5zdXJlQXRvbVN0YXRlKSA9PiB7XG4gIGNvbnN0IGF0b21TdGF0ZSA9IGVuc3VyZUF0b21TdGF0ZShhdG9tKTtcbiAgY29uc3QgaGFzUHJldlZhbHVlID0gXCJ2XCIgaW4gYXRvbVN0YXRlO1xuICBjb25zdCBwcmV2VmFsdWUgPSBhdG9tU3RhdGUudjtcbiAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgZm9yIChjb25zdCBhIG9mIGF0b21TdGF0ZS5kLmtleXMoKSkge1xuICAgICAgYWRkUGVuZGluZ1Byb21pc2VUb0RlcGVuZGVuY3koYXRvbSwgdmFsdWVPclByb21pc2UsIGVuc3VyZUF0b21TdGF0ZShhKSk7XG4gICAgfVxuICB9XG4gIGF0b21TdGF0ZS52ID0gdmFsdWVPclByb21pc2U7XG4gIGRlbGV0ZSBhdG9tU3RhdGUuZTtcbiAgaWYgKCFoYXNQcmV2VmFsdWUgfHwgIU9iamVjdC5pcyhwcmV2VmFsdWUsIGF0b21TdGF0ZS52KSkge1xuICAgICsrYXRvbVN0YXRlLm47XG4gICAgaWYgKGlzUHJvbWlzZUxpa2UocHJldlZhbHVlKSkge1xuICAgICAgYWJvcnRQcm9taXNlKHByZXZWYWx1ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgZ2V0TW91bnRlZE9yUGVuZGluZ0RlcGVuZGVudHMgPSAoYXRvbSwgYXRvbVN0YXRlLCBtb3VudGVkTWFwKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgZGVwZW5kZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgYSBvZiAoKF9hID0gbW91bnRlZE1hcC5nZXQoYXRvbSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50KSB8fCBbXSkge1xuICAgIGlmIChtb3VudGVkTWFwLmhhcyhhKSkge1xuICAgICAgZGVwZW5kZW50cy5hZGQoYSk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgYXRvbVdpdGhQZW5kaW5nUHJvbWlzZSBvZiBhdG9tU3RhdGUucCkge1xuICAgIGRlcGVuZGVudHMuYWRkKGF0b21XaXRoUGVuZGluZ1Byb21pc2UpO1xuICB9XG4gIHJldHVybiBkZXBlbmRlbnRzO1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlSG9vayA9ICgpID0+IHtcbiAgY29uc3QgY2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgbm90aWZ5ID0gKCkgPT4ge1xuICAgIGNhbGxiYWNrcy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIH07XG4gIG5vdGlmeS5hZGQgPSAoZm4pID0+IHtcbiAgICBjYWxsYmFja3MuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FsbGJhY2tzLmRlbGV0ZShmbik7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIG5vdGlmeTtcbn07XG5jb25zdCBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcyA9ICgpID0+IHtcbiAgY29uc3QgYWxsID0ge307XG4gIGNvbnN0IGNhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBub3RpZnkgPSAoYXRvbSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gY2FsbGJhY2tzLmdldChhbGwpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoZm4pID0+IGZuKGF0b20pKTtcbiAgICAoX2IgPSBjYWxsYmFja3MuZ2V0KGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICB9O1xuICBub3RpZnkuYWRkID0gKGF0b20sIGZuKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gYXRvbSB8fCBhbGw7XG4gICAgY29uc3QgZm5zID0gKGNhbGxiYWNrcy5oYXMoa2V5KSA/IGNhbGxiYWNrcyA6IGNhbGxiYWNrcy5zZXQoa2V5LCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSkuZ2V0KGtleSk7XG4gICAgZm5zLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZucyA9PSBudWxsID8gdm9pZCAwIDogZm5zLmRlbGV0ZShmbik7XG4gICAgICBpZiAoIWZucy5zaXplKSB7XG4gICAgICAgIGNhbGxiYWNrcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gbm90aWZ5O1xufTtcbmNvbnN0IGluaXRpYWxpemVTdG9yZUhvb2tzID0gKHN0b3JlSG9va3MpID0+IHtcbiAgc3RvcmVIb29rcy5jIHx8IChzdG9yZUhvb2tzLmMgPSBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcygpKTtcbiAgc3RvcmVIb29rcy5tIHx8IChzdG9yZUhvb2tzLm0gPSBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcygpKTtcbiAgc3RvcmVIb29rcy51IHx8IChzdG9yZUhvb2tzLnUgPSBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcygpKTtcbiAgc3RvcmVIb29rcy5mIHx8IChzdG9yZUhvb2tzLmYgPSBjcmVhdGVTdG9yZUhvb2soKSk7XG4gIHJldHVybiBzdG9yZUhvb2tzO1xufTtcbmNvbnN0IEJVSUxESU5HX0JMT0NLUyA9IFN5bWJvbCgpO1xuY29uc3QgZ2V0QnVpbGRpbmdCbG9ja3MgPSAoc3RvcmUpID0+IHN0b3JlW0JVSUxESU5HX0JMT0NLU107XG5jb25zdCBidWlsZFN0b3JlID0gKGF0b21TdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBtb3VudGVkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGludmFsaWRhdGVkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgY2hhbmdlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbW91bnRDYWxsYmFja3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCB1bm1vdW50Q2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgc3RvcmVIb29rcyA9IHt9LCBhdG9tUmVhZCA9IChhdG9tLCAuLi5wYXJhbXMpID0+IGF0b20ucmVhZCguLi5wYXJhbXMpLCBhdG9tV3JpdGUgPSAoYXRvbSwgLi4ucGFyYW1zKSA9PiBhdG9tLndyaXRlKC4uLnBhcmFtcyksIGF0b21PbkluaXQgPSAoYXRvbSwgc3RvcmUpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gYXRvbS51bnN0YWJsZV9vbkluaXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGF0b20sIHN0b3JlKTtcbn0sIGF0b21Pbk1vdW50ID0gKGF0b20sIHNldEF0b20pID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gYXRvbS5vbk1vdW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChhdG9tLCBzZXRBdG9tKTtcbn0sIC4uLmJ1aWxkaW5nQmxvY2tGdW5jdGlvbnMpID0+IHtcbiAgY29uc3QgZW5zdXJlQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja0Z1bmN0aW9uc1swXSB8fCAoKGF0b20pID0+IHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWF0b20pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0b20gaXMgdW5kZWZpbmVkIG9yIG51bGxcIik7XG4gICAgfVxuICAgIGxldCBhdG9tU3RhdGUgPSBhdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICAgIGlmICghYXRvbVN0YXRlKSB7XG4gICAgICBhdG9tU3RhdGUgPSB7IGQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG46IDAgfTtcbiAgICAgIGF0b21TdGF0ZU1hcC5zZXQoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICAgIGF0b21PbkluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGF0b21PbkluaXQoYXRvbSwgc3RvcmUpO1xuICAgIH1cbiAgICByZXR1cm4gYXRvbVN0YXRlO1xuICB9KTtcbiAgY29uc3QgZmx1c2hDYWxsYmFja3MgPSBidWlsZGluZ0Jsb2NrRnVuY3Rpb25zWzFdIHx8ICgoKSA9PiB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2FsbCA9IChmbikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkbyB7XG4gICAgICBpZiAoc3RvcmVIb29rcy5mKSB7XG4gICAgICAgIGNhbGwoc3RvcmVIb29rcy5mKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBhZGQgPSBjYWxsYmFja3MuYWRkLmJpbmQoY2FsbGJhY2tzKTtcbiAgICAgIGNoYW5nZWRBdG9tcy5mb3JFYWNoKChhdG9tKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EubC5mb3JFYWNoKGFkZCk7XG4gICAgICB9KTtcbiAgICAgIGNoYW5nZWRBdG9tcy5jbGVhcigpO1xuICAgICAgdW5tb3VudENhbGxiYWNrcy5mb3JFYWNoKGFkZCk7XG4gICAgICB1bm1vdW50Q2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgICBtb3VudENhbGxiYWNrcy5mb3JFYWNoKGFkZCk7XG4gICAgICBtb3VudENhbGxiYWNrcy5jbGVhcigpO1xuICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbCk7XG4gICAgICBpZiAoY2hhbmdlZEF0b21zLnNpemUpIHtcbiAgICAgICAgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcygpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoYW5nZWRBdG9tcy5zaXplIHx8IHVubW91bnRDYWxsYmFja3Muc2l6ZSB8fCBtb3VudENhbGxiYWNrcy5zaXplKTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEFnZ3JlZ2F0ZUVycm9yKGVycm9ycyk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcyA9IGJ1aWxkaW5nQmxvY2tGdW5jdGlvbnNbMl0gfHwgKCgpID0+IHtcbiAgICBjb25zdCB0b3BTb3J0ZWRSZXZlcnNlZCA9IFtdO1xuICAgIGNvbnN0IHZpc2l0aW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgY29uc3QgdmlzaXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIGNvbnN0IHN0YWNrID0gQXJyYXkuZnJvbShjaGFuZ2VkQXRvbXMpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGEgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGVuc3VyZUF0b21TdGF0ZShhKTtcbiAgICAgIGlmICh2aXNpdGVkLmhhcyhhKSkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodmlzaXRpbmcuaGFzKGEpKSB7XG4gICAgICAgIGlmIChpbnZhbGlkYXRlZEF0b21zLmdldChhKSA9PT0gYVN0YXRlLm4pIHtcbiAgICAgICAgICB0b3BTb3J0ZWRSZXZlcnNlZC5wdXNoKFthLCBhU3RhdGVdKTtcbiAgICAgICAgfSBlbHNlIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpbnZhbGlkYXRlZEF0b21zLmhhcyhhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIltCdWddIGludmFsaWRhdGVkIGF0b20gZXhpc3RzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuYWRkKGEpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2aXNpdGluZy5hZGQoYSk7XG4gICAgICBmb3IgKGNvbnN0IGQgb2YgZ2V0TW91bnRlZE9yUGVuZGluZ0RlcGVuZGVudHMoYSwgYVN0YXRlLCBtb3VudGVkTWFwKSkge1xuICAgICAgICBpZiAoIXZpc2l0aW5nLmhhcyhkKSkge1xuICAgICAgICAgIHN0YWNrLnB1c2goZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRvcFNvcnRlZFJldmVyc2VkLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBbYSwgYVN0YXRlXSA9IHRvcFNvcnRlZFJldmVyc2VkW2ldO1xuICAgICAgbGV0IGhhc0NoYW5nZWREZXBzID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBhU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKGRlcCAhPT0gYSAmJiBjaGFuZ2VkQXRvbXMuaGFzKGRlcCkpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VkRGVwcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VkRGVwcykge1xuICAgICAgICByZWFkQXRvbVN0YXRlKGEpO1xuICAgICAgICBtb3VudERlcGVuZGVuY2llcyhhKTtcbiAgICAgIH1cbiAgICAgIGludmFsaWRhdGVkQXRvbXMuZGVsZXRlKGEpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHJlYWRBdG9tU3RhdGUgPSBidWlsZGluZ0Jsb2NrRnVuY3Rpb25zWzNdIHx8ICgoYXRvbSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBlbnN1cmVBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKGlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQoYXRvbVN0YXRlKSkge1xuICAgICAgaWYgKG1vdW50ZWRNYXAuaGFzKGF0b20pICYmIGludmFsaWRhdGVkQXRvbXMuZ2V0KGF0b20pICE9PSBhdG9tU3RhdGUubikge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmZyb20oYXRvbVN0YXRlLmQpLmV2ZXJ5KFxuICAgICAgICAoW2EsIG5dKSA9PiAoXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHksIHJlYWQgdGhlIGF0b20gc3RhdGUgb2YgdGhlIGRlcGVuZGVuY3ksIGFuZFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBhdG9tIGVwb2NoIG51bWJlciBpcyB1bmNoYW5nZWRcbiAgICAgICAgICByZWFkQXRvbVN0YXRlKGEpLm4gPT09IG5cbiAgICAgICAgKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBhdG9tU3RhdGUuZC5jbGVhcigpO1xuICAgIGxldCBpc1N5bmMgPSB0cnVlO1xuICAgIGNvbnN0IG1vdW50RGVwZW5kZW5jaWVzSWZBc3luYyA9ICgpID0+IHtcbiAgICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSkge1xuICAgICAgICBtb3VudERlcGVuZGVuY2llcyhhdG9tKTtcbiAgICAgICAgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcygpO1xuICAgICAgICBmbHVzaENhbGxiYWNrcygpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0dGVyID0gKGEpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICBjb25zdCBhU3RhdGUyID0gZW5zdXJlQXRvbVN0YXRlKGEpO1xuICAgICAgICBpZiAoIWlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQoYVN0YXRlMikpIHtcbiAgICAgICAgICBpZiAoaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgICBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZShhLCBhLmluaXQsIGVuc3VyZUF0b21TdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGF0b20gaW5pdFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybkF0b21WYWx1ZShhU3RhdGUyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFTdGF0ZSA9IHJlYWRBdG9tU3RhdGUoYSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhdG9tU3RhdGUuZC5zZXQoYSwgYVN0YXRlLm4pO1xuICAgICAgICBpZiAoaXNQZW5kaW5nUHJvbWlzZShhdG9tU3RhdGUudikpIHtcbiAgICAgICAgICBhZGRQZW5kaW5nUHJvbWlzZVRvRGVwZW5kZW5jeShhdG9tLCBhdG9tU3RhdGUudiwgYVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAoX2EyID0gbW91bnRlZE1hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIudC5hZGQoYXRvbSk7XG4gICAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgICAgbW91bnREZXBlbmRlbmNpZXNJZkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGxldCBzZXRTZWxmO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICBpZiAoIWNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIH0sXG4gICAgICBnZXQgc2V0U2VsZigpIHtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHJlYWQtb25seSBhdG9tXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2V0U2VsZiAmJiBpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgc2V0U2VsZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTeW5jKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCBpbiBzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVBdG9tU3RhdGUoYXRvbSwgLi4uYXJncyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcygpO1xuICAgICAgICAgICAgICAgIGZsdXNoQ2FsbGJhY2tzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRTZWxmO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJldkVwb2NoTnVtYmVyID0gYXRvbVN0YXRlLm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbHVlT3JQcm9taXNlID0gYXRvbVJlYWQoYXRvbSwgZ2V0dGVyLCBvcHRpb25zKTtcbiAgICAgIHNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlKGF0b20sIHZhbHVlT3JQcm9taXNlLCBlbnN1cmVBdG9tU3RhdGUpO1xuICAgICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgICAgIHJlZ2lzdGVyQWJvcnRIYW5kbGVyKHZhbHVlT3JQcm9taXNlLCAoKSA9PiBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmFib3J0KCkpO1xuICAgICAgICB2YWx1ZU9yUHJvbWlzZS50aGVuKFxuICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzSWZBc3luYyxcbiAgICAgICAgICBtb3VudERlcGVuZGVuY2llc0lmQXN5bmNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlbGV0ZSBhdG9tU3RhdGUudjtcbiAgICAgIGF0b21TdGF0ZS5lID0gZXJyb3I7XG4gICAgICArK2F0b21TdGF0ZS5uO1xuICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNTeW5jID0gZmFsc2U7XG4gICAgICBpZiAocHJldkVwb2NoTnVtYmVyICE9PSBhdG9tU3RhdGUubiAmJiBpbnZhbGlkYXRlZEF0b21zLmdldChhdG9tKSA9PT0gcHJldkVwb2NoTnVtYmVyKSB7XG4gICAgICAgIGludmFsaWRhdGVkQXRvbXMuc2V0KGF0b20sIGF0b21TdGF0ZS5uKTtcbiAgICAgICAgY2hhbmdlZEF0b21zLmFkZChhdG9tKTtcbiAgICAgICAgKF9hID0gc3RvcmVIb29rcy5jKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChzdG9yZUhvb2tzLCBhdG9tKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBpbnZhbGlkYXRlRGVwZW5kZW50cyA9IGJ1aWxkaW5nQmxvY2tGdW5jdGlvbnNbNF0gfHwgKChhdG9tKSA9PiB7XG4gICAgY29uc3Qgc3RhY2sgPSBbYXRvbV07XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgY29uc3QgYSA9IHN0YWNrLnBvcCgpO1xuICAgICAgY29uc3QgYVN0YXRlID0gZW5zdXJlQXRvbVN0YXRlKGEpO1xuICAgICAgZm9yIChjb25zdCBkIG9mIGdldE1vdW50ZWRPclBlbmRpbmdEZXBlbmRlbnRzKGEsIGFTdGF0ZSwgbW91bnRlZE1hcCkpIHtcbiAgICAgICAgY29uc3QgZFN0YXRlID0gZW5zdXJlQXRvbVN0YXRlKGQpO1xuICAgICAgICBpbnZhbGlkYXRlZEF0b21zLnNldChkLCBkU3RhdGUubik7XG4gICAgICAgIHN0YWNrLnB1c2goZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgd3JpdGVBdG9tU3RhdGUgPSBidWlsZGluZ0Jsb2NrRnVuY3Rpb25zWzVdIHx8ICgoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIGxldCBpc1N5bmMgPSB0cnVlO1xuICAgIGNvbnN0IGdldHRlciA9IChhKSA9PiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZShhKSk7XG4gICAgY29uc3Qgc2V0dGVyID0gKGEsIC4uLmFyZ3MyKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBhU3RhdGUgPSBlbnN1cmVBdG9tU3RhdGUoYSk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdG9tIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHJldkVwb2NoTnVtYmVyID0gYVN0YXRlLm47XG4gICAgICAgICAgY29uc3QgdiA9IGFyZ3MyWzBdO1xuICAgICAgICAgIHNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlKGEsIHYsIGVuc3VyZUF0b21TdGF0ZSk7XG4gICAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoYSk7XG4gICAgICAgICAgaWYgKHByZXZFcG9jaE51bWJlciAhPT0gYVN0YXRlLm4pIHtcbiAgICAgICAgICAgIGNoYW5nZWRBdG9tcy5hZGQoYSk7XG4gICAgICAgICAgICAoX2EgPSBzdG9yZUhvb2tzLmMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHN0b3JlSG9va3MsIGEpO1xuICAgICAgICAgICAgaW52YWxpZGF0ZURlcGVuZGVudHMoYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQXRvbVN0YXRlKGEsIC4uLmFyZ3MyKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgICByZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zKCk7XG4gICAgICAgICAgZmx1c2hDYWxsYmFja3MoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhdG9tV3JpdGUoYXRvbSwgZ2V0dGVyLCBzZXR0ZXIsIC4uLmFyZ3MpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtb3VudERlcGVuZGVuY2llcyA9IGJ1aWxkaW5nQmxvY2tGdW5jdGlvbnNbNl0gfHwgKChhdG9tKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGVuc3VyZUF0b21TdGF0ZShhdG9tKTtcbiAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKG1vdW50ZWQgJiYgIWlzUGVuZGluZ1Byb21pc2UoYXRvbVN0YXRlLnYpKSB7XG4gICAgICBmb3IgKGNvbnN0IFthLCBuXSBvZiBhdG9tU3RhdGUuZCkge1xuICAgICAgICBpZiAoIW1vdW50ZWQuZC5oYXMoYSkpIHtcbiAgICAgICAgICBjb25zdCBhU3RhdGUgPSBlbnN1cmVBdG9tU3RhdGUoYSk7XG4gICAgICAgICAgY29uc3QgYU1vdW50ZWQgPSBtb3VudEF0b20oYSk7XG4gICAgICAgICAgYU1vdW50ZWQudC5hZGQoYXRvbSk7XG4gICAgICAgICAgbW91bnRlZC5kLmFkZChhKTtcbiAgICAgICAgICBpZiAobiAhPT0gYVN0YXRlLm4pIHtcbiAgICAgICAgICAgIGNoYW5nZWRBdG9tcy5hZGQoYSk7XG4gICAgICAgICAgICAoX2EgPSBzdG9yZUhvb2tzLmMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHN0b3JlSG9va3MsIGEpO1xuICAgICAgICAgICAgaW52YWxpZGF0ZURlcGVuZGVudHMoYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGEgb2YgbW91bnRlZC5kIHx8IFtdKSB7XG4gICAgICAgIGlmICghYXRvbVN0YXRlLmQuaGFzKGEpKSB7XG4gICAgICAgICAgbW91bnRlZC5kLmRlbGV0ZShhKTtcbiAgICAgICAgICBjb25zdCBhTW91bnRlZCA9IHVubW91bnRBdG9tKGEpO1xuICAgICAgICAgIGFNb3VudGVkID09IG51bGwgPyB2b2lkIDAgOiBhTW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG1vdW50QXRvbSA9IGJ1aWxkaW5nQmxvY2tGdW5jdGlvbnNbN10gfHwgKChhdG9tKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGVuc3VyZUF0b21TdGF0ZShhdG9tKTtcbiAgICBsZXQgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgIGlmICghbW91bnRlZCkge1xuICAgICAgcmVhZEF0b21TdGF0ZShhdG9tKTtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgYU1vdW50ZWQgPSBtb3VudEF0b20oYSk7XG4gICAgICAgIGFNb3VudGVkLnQuYWRkKGF0b20pO1xuICAgICAgfVxuICAgICAgbW91bnRlZCA9IHtcbiAgICAgICAgbDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgICAgZDogbmV3IFNldChhdG9tU3RhdGUuZC5rZXlzKCkpLFxuICAgICAgICB0OiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgICB9O1xuICAgICAgbW91bnRlZE1hcC5zZXQoYXRvbSwgbW91bnRlZCk7XG4gICAgICAoX2EgPSBzdG9yZUhvb2tzLm0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHN0b3JlSG9va3MsIGF0b20pO1xuICAgICAgaWYgKGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc09uTW91bnQgPSAoKSA9PiB7XG4gICAgICAgICAgbGV0IGlzU3luYyA9IHRydWU7XG4gICAgICAgICAgY29uc3Qgc2V0QXRvbSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gd3JpdGVBdG9tU3RhdGUoYXRvbSwgLi4uYXJncyk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICAgICAgICAgIHJlY29tcHV0ZUludmFsaWRhdGVkQXRvbXMoKTtcbiAgICAgICAgICAgICAgICBmbHVzaENhbGxiYWNrcygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb25Vbm1vdW50ID0gYXRvbU9uTW91bnQoYXRvbSwgc2V0QXRvbSk7XG4gICAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgIG1vdW50ZWQudSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBvblVubW91bnQoKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaXNTeW5jID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1vdW50Q2FsbGJhY2tzLmFkZChwcm9jZXNzT25Nb3VudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb3VudGVkO1xuICB9KTtcbiAgY29uc3QgdW5tb3VudEF0b20gPSBidWlsZGluZ0Jsb2NrRnVuY3Rpb25zWzhdIHx8ICgoYXRvbSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBlbnN1cmVBdG9tU3RhdGUoYXRvbSk7XG4gICAgbGV0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5sLnNpemUgJiYgIUFycmF5LmZyb20obW91bnRlZC50KS5zb21lKChhKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIChfYTIgPSBtb3VudGVkTWFwLmdldChhKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kLmhhcyhhdG9tKTtcbiAgICB9KSkge1xuICAgICAgaWYgKG1vdW50ZWQudSkge1xuICAgICAgICB1bm1vdW50Q2FsbGJhY2tzLmFkZChtb3VudGVkLnUpO1xuICAgICAgfVxuICAgICAgbW91bnRlZCA9IHZvaWQgMDtcbiAgICAgIG1vdW50ZWRNYXAuZGVsZXRlKGF0b20pO1xuICAgICAgKF9hID0gc3RvcmVIb29rcy51KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChzdG9yZUhvb2tzLCBhdG9tKTtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgYU1vdW50ZWQgPSB1bm1vdW50QXRvbShhKTtcbiAgICAgICAgYU1vdW50ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGFNb3VudGVkLnQuZGVsZXRlKGF0b20pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH0pO1xuICBjb25zdCBidWlsZGluZ0Jsb2NrcyA9IFtcbiAgICAvLyBzdG9yZSBzdGF0ZVxuICAgIGF0b21TdGF0ZU1hcCxcbiAgICBtb3VudGVkTWFwLFxuICAgIGludmFsaWRhdGVkQXRvbXMsXG4gICAgY2hhbmdlZEF0b21zLFxuICAgIG1vdW50Q2FsbGJhY2tzLFxuICAgIHVubW91bnRDYWxsYmFja3MsXG4gICAgc3RvcmVIb29rcyxcbiAgICAvLyBhdG9tIGludGVyY2VwdG9yc1xuICAgIGF0b21SZWFkLFxuICAgIGF0b21Xcml0ZSxcbiAgICBhdG9tT25Jbml0LFxuICAgIGF0b21Pbk1vdW50LFxuICAgIC8vIGJ1aWxkaW5nLWJsb2NrIGZ1bmN0aW9uc1xuICAgIGVuc3VyZUF0b21TdGF0ZSxcbiAgICBmbHVzaENhbGxiYWNrcyxcbiAgICByZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zLFxuICAgIHJlYWRBdG9tU3RhdGUsXG4gICAgaW52YWxpZGF0ZURlcGVuZGVudHMsXG4gICAgd3JpdGVBdG9tU3RhdGUsXG4gICAgbW91bnREZXBlbmRlbmNpZXMsXG4gICAgbW91bnRBdG9tLFxuICAgIHVubW91bnRBdG9tXG4gIF07XG4gIGNvbnN0IHN0b3JlID0ge1xuICAgIGdldDogKGF0b20pID0+IHJldHVybkF0b21WYWx1ZShyZWFkQXRvbVN0YXRlKGF0b20pKSxcbiAgICBzZXQ6IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd3JpdGVBdG9tU3RhdGUoYXRvbSwgLi4uYXJncyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zKCk7XG4gICAgICAgIGZsdXNoQ2FsbGJhY2tzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdWI6IChhdG9tLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50QXRvbShhdG9tKTtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IG1vdW50ZWQubDtcbiAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgZmx1c2hDYWxsYmFja3MoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICB1bm1vdW50QXRvbShhdG9tKTtcbiAgICAgICAgZmx1c2hDYWxsYmFja3MoKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUsIEJVSUxESU5HX0JMT0NLUywgeyB2YWx1ZTogYnVpbGRpbmdCbG9ja3MgfSk7XG4gIHJldHVybiBzdG9yZTtcbn07XG5jb25zdCBJTlRFUk5BTF9idWlsZFN0b3JlUmV2MSA9IGJ1aWxkU3RvcmU7XG5jb25zdCBJTlRFUk5BTF9nZXRCdWlsZGluZ0Jsb2Nrc1JldjEgPSBnZXRCdWlsZGluZ0Jsb2NrcztcbmNvbnN0IElOVEVSTkFMX2luaXRpYWxpemVTdG9yZUhvb2tzID0gaW5pdGlhbGl6ZVN0b3JlSG9va3M7XG5jb25zdCBJTlRFUk5BTF9pc1NlbGZBdG9tID0gaXNTZWxmQXRvbTtcbmNvbnN0IElOVEVSTkFMX2hhc0luaXRpYWxWYWx1ZSA9IGhhc0luaXRpYWxWYWx1ZTtcbmNvbnN0IElOVEVSTkFMX2lzQWN0dWFsbHlXcml0YWJsZUF0b20gPSBpc0FjdHVhbGx5V3JpdGFibGVBdG9tO1xuY29uc3QgSU5URVJOQUxfaXNBdG9tU3RhdGVJbml0aWFsaXplZCA9IGlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQ7XG5jb25zdCBJTlRFUk5BTF9yZXR1cm5BdG9tVmFsdWUgPSByZXR1cm5BdG9tVmFsdWU7XG5jb25zdCBJTlRFUk5BTF9wcm9taXNlU3RhdGVNYXAgPSBwcm9taXNlU3RhdGVNYXA7XG5jb25zdCBJTlRFUk5BTF9pc1BlbmRpbmdQcm9taXNlID0gaXNQZW5kaW5nUHJvbWlzZTtcbmNvbnN0IElOVEVSTkFMX2Fib3J0UHJvbWlzZSA9IGFib3J0UHJvbWlzZTtcbmNvbnN0IElOVEVSTkFMX3JlZ2lzdGVyQWJvcnRIYW5kbGVyID0gcmVnaXN0ZXJBYm9ydEhhbmRsZXI7XG5jb25zdCBJTlRFUk5BTF9pc1Byb21pc2VMaWtlID0gaXNQcm9taXNlTGlrZTtcbmNvbnN0IElOVEVSTkFMX2FkZFBlbmRpbmdQcm9taXNlVG9EZXBlbmRlbmN5ID0gYWRkUGVuZGluZ1Byb21pc2VUb0RlcGVuZGVuY3k7XG5jb25zdCBJTlRFUk5BTF9zZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZSA9IHNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlO1xuY29uc3QgSU5URVJOQUxfZ2V0TW91bnRlZE9yUGVuZGluZ0RlcGVuZGVudHMgPSBnZXRNb3VudGVkT3JQZW5kaW5nRGVwZW5kZW50cztcblxuZXhwb3J0IHsgSU5URVJOQUxfYWJvcnRQcm9taXNlLCBJTlRFUk5BTF9hZGRQZW5kaW5nUHJvbWlzZVRvRGVwZW5kZW5jeSwgSU5URVJOQUxfYnVpbGRTdG9yZVJldjEsIElOVEVSTkFMX2dldEJ1aWxkaW5nQmxvY2tzUmV2MSwgSU5URVJOQUxfZ2V0TW91bnRlZE9yUGVuZGluZ0RlcGVuZGVudHMsIElOVEVSTkFMX2hhc0luaXRpYWxWYWx1ZSwgSU5URVJOQUxfaW5pdGlhbGl6ZVN0b3JlSG9va3MsIElOVEVSTkFMX2lzQWN0dWFsbHlXcml0YWJsZUF0b20sIElOVEVSTkFMX2lzQXRvbVN0YXRlSW5pdGlhbGl6ZWQsIElOVEVSTkFMX2lzUGVuZGluZ1Byb21pc2UsIElOVEVSTkFMX2lzUHJvbWlzZUxpa2UsIElOVEVSTkFMX2lzU2VsZkF0b20sIElOVEVSTkFMX3Byb21pc2VTdGF0ZU1hcCwgSU5URVJOQUxfcmVnaXN0ZXJBYm9ydEhhbmRsZXIsIElOVEVSTkFMX3JldHVybkF0b21WYWx1ZSwgSU5URVJOQUxfc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla/internals.mjs\n");

/***/ })

};
;